#1. 正则表达式
'''
正则表达式是一种用来匹配字符串的强有力的武器，它的设计思想是用一种描述性的语言来给字符串定义一个
规则，凡是符合规则的字符串，我们就认为它'匹配'了，否则，该字符串就是不合法的。
'''
#判断一个字符串是否是合法的Email的方法是：
#1.创建一个匹配Email的正则表达式
#2.用该正则表达式去匹配用户的输入来判断是否合法。
#正则表达式也是用字符串表示的，在正则表达式中，如果直接给出字符，就是精确匹配。
"""
用\d可以匹配一个数字，\w可以匹配一个字母或数字，用.可以匹配任意字符,\s表示可以匹配一个空格
要匹配变长的字符，在正则表达式中，用*表示前面元素出现0次或多次，用+表示前面元素至少出现1次
用？表示匹配前面的0个或1个字符，用{n}表示n个字符，用{n,m}表示n到m个字符。
"""
#一个正则表达式：\d{3}\s+\d{3,8},从左到右解读
#1.\d{3}表示匹配3个数字
#2.\s可以匹配一个空格(包括Tab等空白符)，所以\s+表示至少有一个空格，例如匹配' ','	'等
#3.\d{3,8}表示3到8个数字，例如:'1234567'
#特殊字符需要'\'转义。
#2. 正则表达式进阶
"""
要更精确的匹配，可以用[]表示范围.
"""
#[0-9a-zA-Z\_]可以匹配一个数字0-9，一个字母a-zA-Z或者下划线_(_是特殊字符，需要用'\'转义)
#[0-9a-zA-Z\_]+可以匹配至少由一个数字，字母或者下划线组成的字符串。例如：'a100','0_z'等
#[a-zA-z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字，字母或者字符串组成的字符串。也就是python的合法变量
#[a-zA-Z\_][0-9a-zA-Z\_]{0-19}更精确的限制了变量的长度是1-20个字符(前面1个字符+后面最多19个字符)
"""
A|B可以匹配A或则B,所有[p|P]ython可以匹配'python'或者'Python'
^表示行的开头，^\d表示必须以数字开头。
$表示行的结束，\d$表示必须以数字结束。
"""
#3. re模块
#python提供re模块，包含所有正则表达式的功能，由于python的字符串本身也用\转义。
'''
s='ABC\\-001'#Python的字符串
#对应的正则表达式字符串变成：'ABC\-001'(把\当成特殊字符对待了，前面使用了转义字符\)
'''
#建议使用python 的r前缀，就不用考虑转义的问题了
'''
s=r'ABC\\-001'#Python的字符串
#对应的正则表达式字符串不变：
# 'ABC\\-001'
'''
s='ABC\\-001'
print(s)
s1=r'ABC\\-001'
print(s1)

#如何判断一个正则表达式是否匹配：
import re
print(re.match(r'^\d{3}\-\d{3,8}$','010-12345'))
print(re.match(r'^\d{3}\-\d{3,8}$','23-12345'))
#match()方法判断是否匹配，如果成功匹配，返回一个Match对象，否则返回None。
#常见的判断方法模型：
'''
test='用户输入的字符串'
if re.match(f'正则表达式',test):
	print('ok')
else:
	print('failed')
'''
#4. 切分字符串
#用正则表达式切分字符串比用固定的字符更灵活。
#正常的切分代码：
print('a b   c'.split(' '))#以空格为分界切割字符串
#无法识别连续的空格，可以用正则表达式
print(re.split(r'\s+','a b   c'))#无论多少个空格都可以正常分割，以一个至少一个空格为分割符
print(re.split(r'[\s\,]+','a,b,,sds    f d'))#以至少一个空格或者,为分割符 
print(re.split(r'[\s\,\;]+','a;d,f  sds,f;sdsd'))

#5.分组
#除了简单的匹配之外，正则表达式还有提取子串的功能，用()表示的就是要提取的分组(group)
# ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取区号和本地号码
m=re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
print(m)
print(m.group(0))
print(m.group(1))
print(m.group(2))
#如果在正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来
#group(0)永远是原始的字符串，group(1)表示第一个子串，依次类推

t='19:05:30'
m=re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$',t)
print(m.groups())
print(m.group(0))

#5.贪婪匹配，正则表达式默认的是贪婪匹配，也就是尽可能多的匹配字符
print(re.match(r'^(\d+)(0*)$','10330000').groups())
#由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了
#必须让\d+采用非贪婪匹配(也就是尽可能的少匹配)，才能把后面的0匹配出来，加个？就可以让\d+采用非贪婪匹配
print(re.match(r'^(\d+?)(0*)$','1230230000').group(2))

#6.编译
#re模块首先会编译正则表达式，如果正则表达式的字符串本身不合法，会报错，编译后会去匹配字符串。
#如果一个正则表达式要重复使用几千次，处于效率考虑，可以预编译该正则表达式，接下来重复使用就不需要编译步骤了，直接匹配
import re
#编译：
re_telephone=re.compile(r'^(\d{3})-(\d{3,8})$')
#使用：
print(re_telephone.match('010-12345').groups())
print(re_telephone.match('010-9086').groups())
#注意groups()和group(0)的区别,group(0)表示原始字符串，groups()表示分组后的字符串。

'''
1.练习：尝试写一个验证Email地址的正则表达式。
版本1一应该可以验证出类似的Email
版本2可以验证并提取出带名字的Email地址
'''
import re
test_list=['asd@163.com','kami@gmail.com','asdsdkamisss@microsoft.com','wdeer','adadkami@126.com']
my_gail=re.compile(r'^[0-9a-zA-Z]+@(gmail|microsoft).com')
gamil_list=[i for i in test_list if my_gail.match(i)]
print(gamil_list)

#2.提取带kami的Email地址。
my_name_email=re.compile(r'^[0-9a-zA-Z]*kami[0-9a-zA-Z]*@(gmail|microsoft|163|126).com')
name_email_list=[x for x in test_list if my_name_email.match(x)]
print(name_email_list)